* Logs
:PROPERTIES:
:CUSTOM_ID: logs
:END:


- Memory represented as a Map

  #+begin_src haskell
    type Memory = Map Ide MemVal

    -- Initial Empty Memory
    emptymem :: Memory
    emptymem = Map.empty

    -- Display the memory
    display :: Memory -> String
    display memory = "Memory:\n"
      ++ unlines (map (\(k, v) -> k ++ " -> " ++ show v) (Map.toList memory))

    -- Update the memory with a new value
    update :: Memory -> Ide -> Value -> Memory
    update memory ide val = Map.insert ide (Stored val) memory

    -- Search for the value of the identifier in the memory
    search :: Memory -> Ide -> Value
    search memory ide = case Map.lookup ide memory of
      Just (Stored v) -> Stored v
      _ -> Unbound

  #+end_src

- Memory represented as a tuple of a list of identifiers and a function

  #+begin_src haskell
    type Memory = ([Ide], Ide -> MemVal)

    -- Initial Empty Memory
    emptymem :: Memory
    emptymem = ([], \_ -> Unbound)

    -- Display the memory
    display :: Memory -> String
    display ([], _) = "Memory: []"
    display (ides, f) = "Memory:\n"
      ++ unlines (map (\ide -> ide ++ " -> " ++ show (f ide)) ides)

    -- Update the memory with a new value
    update :: Memory -> Ide -> Value -> Memory
    update (ides, f) ide val = (ide:ides, \x -> if x == ide then Stored val else f x)

    -- Search for the value of the identifier in the memory
    search :: Memory -> Ide -> Value
    search (ides, f) ide = case f ide of
      Just (Stored v) -> Stored v
      _ -> Unbound
  #+end_src

